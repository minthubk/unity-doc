! アニメーションスクリプティング（旧） / Animation Scripting (Legacy)

Unityのアニメーションシステムにより綺麗にアニメーション、スキニングされたキャラクターを作成できます。アニメーションシステムはアニメーションブレンディング、ミキシング、追加アニメーション、歩行サイクルタイム同期、アニメーションレイヤーをサポート、アニメーションプレイバックの様々な要素（時間、スピード、重みつきウェイト）を制御、頂点あたり1・2または4ボーンでのメッシュスキニング、および物理挙動をサポートしたラグドールおよびプロシージャルアニメーションをサポートします。

アニメーションつきキャラクターの作成は2つの要素を含みます：ゲーム世界を ''移動'' させることとそれに合わせて ''アニメーション'' させることです。キャラクターを動かすことについて詳細を学ぶには  [[class-CharacterController|Character Controller page]] を参照下さい。このページはアニメーションにフォーカスします。実際にキャラクターのアニメーションはUnityのスクリプティング インタフェースを通して行われます。

プリセットされたアニメーションの [[http://unity3d.com/support/resources/example-projects/|デモサンプル]] をダウンロードできます。このページで基礎を学んだあとは [[ScriptRef:Animation.html|アニメーション スクリプトインタフェース]] を参照下さい。


[[#AnimBlend]]

!! アニメーションブレンディング

今日のゲームでは、アニメーションブレンディングはキャラクターのスムーズなアニメーションを保証する重要な機能です。アニメータは別々のアニメーション、例えば歩行サイクル、走行サイクル、アイドルまたは射撃、のアニメーションを作成します。ゲームの任意の時点でアイドル状態から歩行サイクルに遷移したり、やその反対の遷移を行うことが出来る必要があります。当然、遷移はスムーズでモーションのずれを回避すべきです。

ここでアニメーション ブレンディングの登場です。Unityでは同じキャラクターで任意の数だけアニメーションを再生させることが出来ます。全てのアニメーションはブレンディングまたは追加されて最終アニメーションを生成します。

最初のステップは、キャラクターのアイドルと歩行アニメーションをスムーズにブレンドさせることです。スクリプト作成者の仕事を軽減させるため、最初にアニメーションの ``Wrap Mode`` を ``Loop`` に設定します。

キャラクターをアニメーションさせる最初のスクリプトはかなり簡単なものです。何らかの方法でキャラクターの移動スピードを検知して、歩行およびアイドルアニメーションの間をフェードさせるのみです。このシンプルなテストをおこなうため、標準的なInputのAxisを使用します。


[@function Update () {
   if (Input.GetAxis("Vertical") > 0.2)
       animation.CrossFade ("walk");
   else
      animation.CrossFade ("idle");
} @]


プロジェクトでスクリプトを使用するためには:-
# Javascriptを作成するため、^^Assets->Create Other->Javascript^^ と選択します。
# そこにコードをコピー＆ペーストします。
# キャラクター上にスクリプトをドラッグ＆ドロップします（アニメーションつきの $$GameObject$$ にアタッチする必要があります。）。

再生ボタンを押すと、キャラクターは上向きの矢印キーを押したときにその場で歩き、キーを離したときにアイドルのポーズに戻ります。


[[#AnimLayers]]

!! アニメーションレイヤー

レイヤーはきわめて便利な概念で、アニメーションをグルーピングして重みづけすることが出来ます。

Unityのアニメーション システムは好きなだけアニメーションクリップをのブレンドをすることが出来ます。ブレンドの重みづけはマニュアルで割り当てるか、 ``animation.CrossFade()`` を単に使用して自動的に重みづけすることが出来ます。


!!! ブレンドの適用前に常に行われる重みの正規化

例えば、歩行サイクルと走行サイクルがあり、ともに重み（weight）が 1 (100%)であるとします。Unityが最終アニメーションを生成するとき、重みの正規化が行われる、すなわち歩行サイクルはアニメーションの50%となり、走行サイクルもまた50%となります。

しかし一般的には、二つのアニメーションが再生されているときに、どのアニメーションがもっとも重みづけされるか優先順をつけたいことがあります。重みの合計が100%となるようにマニュアルで調整することも当然できますが、レイヤーをこの目的で使用するのがもっとも簡単です。


[[#LayerExample]]

!!! レイヤー作成 サンプル

例として、射撃、アイドル、歩行サイクルのアニメーションがあるとします。歩行およびアイドルのアニメーションはプレイヤーのスピードにもとづいてブレンドされますが、プレイヤーが撃つときは、射撃アニメーションのみを表示したいかもしれません。したがって、撃つアニメーションは本来的に優先順位を高くします。

これを実現するもっとも簡単な方法は撃つときも歩行およびアイドルアニメーションを保持することです。このためには、射撃アニメーションがアイドルや歩行アニメーションよりも上位のレイヤーとする、すなわち射撃アニメーションが最初にブレンドの重みづけを配分される、必要があります。射撃のアニメーションがブレンド重みづけで100%使い切らない場合に限り、歩行とアイドルのアニメーションは重みづけを配分されません。もし、射撃アニメーションがクロスフェードするとき、重みづけはゼロで始まり、短い期間の間に100%となります。最初、歩行やアイドルレイヤーはブレンドの重みづけを配分されますが、完全に射撃アニメーションがフェードインすると、まったく重みづけを受けなくなります。実現したいことそのものですね！


[@function Start () {
   // 全てのアニメーションをループに設定
   animation.wrapMode = WrapMode.Loop;
   // ただし射撃は除く
   animation["shoot"].wrapMode = WrapMode.Once;

   // アイドルと歩行を下位レイヤーとします（デフォルトではレイヤーは0）
   // 二つのことが行われます
   // - 射撃およびアイドル／歩行は別のレイヤーにあるため、それぞれ
   //   CrossFadeをコールしたときにそれぞれのプレイバックに影響しません
   // - 射撃が上位レイヤーにあるため、アニメーションがフェードインしたとき、アイドル／歩行アニメーション
   //   が置きかえられます。
   animation["shoot"].layer = 1;

   // すでに再生されているアニメーションを止めます
   //（ユーザが再生を無効化したことを忘れた場合に備えて自動的に）
   animation.Stop();
}

function Update () {
   // 押されたキーにもとづいて、
   // 歩行またはアイドルアニメーションを再生します
   if (Mathf.Abs(Input.GetAxis("Vertical")) > 0.1)
      animation.CrossFade("walk");
   else
      animation.CrossFade("idle");

   // 射撃を行う
   if (Input.GetButtonDown ("Fire1"))
      animation.CrossFade("shoot");
} @]

デフォルトで ``animation.Play()`` および ``animation.CrossFade()`` は同じレイヤーにあるアニメーションを停止またはフェードアウトさせます。多くのケースではこれがまさに望ましい動作です。射撃、アイドル、走行の例では、アイドルや走行を再生することでは、射撃アニメーションは影響されず、その逆もまた然りです（この動作はanimation.CrossFade のオプション パラメータを変更することで変更可能です）。

[[#AnimMixing]]

!! アニメーション ミキシング

アニメーション ミキシングにより、いくつかのアニメーションが体の一部のみに適用させることによりゲームで作成する必要があるアニメーション数をカットすることが出来ます。つまり、こういったアニメーションを他のアニメーションと様々なコンピネーションで使用することが出来るということです。

アニメーションにアニメーション ミキシングのTransformを追加するには特定のアニメーションステートで ``AddMixingTransform()`` をコールします。

[[#MixingExample]]

!!! ミキシングのサンプル

ミキシングの例は、たとえば手を振るアニメーションかもしれません。キャラクターがアイドルまたは歩いているときにキャラクターに手を振るようにしたいとします。アニメーション ミキシングを使わないと、アイドルと歩行でそれぞれ手を振るアニメーションを別々に作成する必要があります。しかし、肩のTransformを手を振るアニメ―ションに対するミキシングTransfomとすれば、手を振るアニメーションが肩のJointから頭の部分のみ完全にコントロールします。体の残り部分は手を振る動作に影響を受けないため、アイドルまたは歩く動作を続けます。結果として、アイドルまたは歩くアニメーションを体の残りの部分が行っている間に手を振るアニメーションはひとつのみ必要ということになります。

[@/// Transform変数を用いてミキシングTransformを追加
var shoulder : Transform;
animation["wave_hand"].AddMixingTransform(shoulder);@]

Another example using a path.
[@function Start () {
   // パスを用いてミキシングTransformを追加
   var mixTransform : Transform = transform.Find("root/upper_body/left_shoulder");
   animation["wave_hand"].AddMixingTransform(mixTransform);
}@]


[[#Additive]]

!! 追加アニメーション

追加アニメーションおよびアニメーションミキシングによりゲームで作るべきアニメーションの数を減らすことが出来るとともに、顔の表情を作成するのに重要です。

例えば、歩いたり走ったりする際に斜めに寄るキャラクターを作成したいとします。これは4つのコンビネーションにつながり（歩く-左に寄る、歩く-右に寄る、走る-左に寄る、走る-右に寄る）、各々アニメーションが必要です。それぞれのコンビネーションで別々のアニメーションに作成することは、このシンプルなケースですらも明らかに余分な作業につながりますが、追加アニメーションを追加するごとに飛躍的に増加します。幸いに追加アニメーションおよびミキシングによりシンプルな動作のコンビネーションで別々のアニメーションを生成する必要性を避けます。


!!! 追加アニメーションサンプル

追加アニメーションによりひとつのアニメーションのエフェクトを再生している別のアニメーションに重ね合わせることが出来ます。追加アニメーションを生成するとき、Unityはアニメーションクリップの最初のフレームおよび現在のフレームとの差分を算出します。次に、再生しているアニメーションの上にこの差分を適用します。

先述の例について触れると、アニメーションを左右に寄るアニメーションを作成すれば、Unityはこれらを歩行、アイドル、走行サイクルに重ね合わせることが出来ます。これは次のようなコードにより実現できます:-

[@private var leanLeft : AnimationState;
private var leanRight : AnimationState;

function Start () {
   leanLeft = animation["leanLeft"];
   leanRight = animation["leanRight"];

   // 寄るアニメ―ションを別のレイヤーに含めることにより
   // CrossFadeｈのコールする他のコールが影響を与えられないようにします。
   leanLeft.layer = 10;
   leanRight.layer = 10;

   // 寄るアニメーションを追加アニメーションにセット
   leanLeft.blendMode = AnimationBlendMode.Additive;
   leanRight.blendMode = AnimationBlendMode.Additive;

   // 寄るアニメーションをClampForeverにセット
   // ClampForeverによりアニメーションはクリップの終わりに
   // 到達しても自動的に停止しません
   leanLeft.wrapMode = WrapMode.ClampForever;
   leanRight.wrapMode = WrapMode.ClampForever;

   // アニメーションを有効化して、完全にフェード
   // Update関数で手動で時間の調整
   // を行うため使用しません
   // その代わりにアニメーションをただ有効化して重みを完全に割当します
   leanRight.enabled = true;
   leanLeft.enabled = true;
   leanRight.weight = 1.0;
   leanLeft.weight = 1.0;

   // テストするときは "walk" アニメーションをループ再生t
   animation["walk"].wrapMode = WrapMode.Loop;
   animation.Play("walk");
}

// 毎フレームごとにどれだけ寄るアニメーションを設定したいかにもとづき、
// 正規化された時間をセット
function Update () {
   var lean = Input.GetAxis("Horizontal");
   // normalizedTime is 0 at the first frame and 1 at the last frame in the clip
   leanLeft.normalizedTime = -lean;
   leanRight.normalizedTime = lean;
} @]


__ヒント:__ 追加アニメーションを使用する際、追加でないアニメーションを、追加アニメーションで使用される全てのTransformで再生することは重要で、そうでない場合はアニメーションは最終フレームの結果に追加されます。ほとんどのケースでこれは望まない結果となります。

[[#Procedural]]

!! キャラクターのプロシージャル アニメーション

ときどきキャラクターのボーンをプロシージャルにアニメーションしたい場合があります。例えば、キャラクターの頭が3D空間の特定の地点を見るようにしたい場合があり、これはターゲット地点をトラッキングするスクリプトにより最も適切にハンドリングできます。幸いに、Unityによりこの作業は、ボーンはスキンメッシュをドライブするただのTransformであるため、非常に簡単です。したがってゲームオブジェクトのTransformと同様に、キャラクターのボーンを制御できます。

知っておくべき重要なこととして、アニメーションシステムは、 ``Update()`` の後で ``LateUpdate()`` の前に、Transformを更新します。したがって ``LookAt()`` 関数を使用したい場合は、本当にアニメーションを確実に上書きするためには ``LateUpdate()`` の中で行います。

Ragdoll は同じ方法で作成します。異なるボーンに Rigidbody 、キャラクター ジョイント、およびカプセル コライダ をアタッチ ``WrapMode.Once`` するのみです。これによってスキニングされたキャラクターに物理的にアニメーションを行います。


[[#Playback]]

!! アニメーションプレイバックおよびサンプリング

このセクションはUnityのアニメーションがどのようにサンプリングされて、エンジンで再生されるかを説明します。

アニメーションクリップは一般的に固定フレームレートでオーサリングされます。例えば、キャラクターを3ds Max または Mayaで60フレーム毎秒（fps）フレームレートで作成したとします。Unityにアニメーションをインポートするとき、このフレームレートはインポータにより読み取りされて、インポートされたアニメーションのデータもまた 60 fps でサンプリングします。

しかし、ゲームは一般的に変動するフレームレートにより実行されます。フレームレートはいくつかのコンピュータでは他よりも高いかもしれず、ある秒から次の秒まで、特定の瞬間にカメラがみているビューの複雑さにもとづいてフレームレートは変動します。これは、ゲームが実行されるフレームレートは基本的に前提にすることができないことを意味します。これはつまり、アニメーションが60 fps でオーサリングされたとしても、オーサリングされたアニメーションと異なるフレームレートでゲームが実行されるかもしれません、例えば56.72 fps とか83.14 fps、あるいはどんな値にでもなりえます。 

結果として、Unityはアニメーションを変動フレームレートでサンプリングする必要があり、もともとデザインされたフレームレートを保証することは出来ません。幸いに、3Dコンピュータグラフィックスのアニメーションは離散的なフレームでなく、むしろ連続的なカーブから構成されます。これらのカーブは、元のアニメーションに対応するフレームだけでなくどの時点でも、サンプリングすることができます。実のところ、ゲームがもとアニメーションがオーサリングされたものより高いフレームレートで実行される場合、アニメーションはアニメーション ソフトウェアよりもスムーズでかつ流れるように見えます。

実践的なほとんどの用途において、Unity変動フレームレートでアニメーションをサンプリングすることを無視できます。しかし、アニメーションのTransformやプロパティを特定のコンフィグに設定するアニメーションに依存するゲームロジックがある場合、再サンプリングが裏で行われることに注意する必要があります。例えば、オブジェクトを 0 度から 180 度まで30フレーム以上で回転させるアニメーションがあり、コードの中からその半分にいつ到達したかを知りたい場合コードの現在の回転が90度であるかをチェックする条件文を入れて対応するべきではありません。Unityがゲームの変動フレームレートでサンプリングを行うため、90度より少し低い角度でサンプリングされるかもしれず、次のタイミングで90度を超えるかもしれません。もしアニメーションが特定の地点に到達したか通知される必要がある場合、 [[animeditor-AnimationEvents | アニメーションイベント]] を使用するべきです。

変動フレームレートによるサンプリングの結果として、 ``WrapMode.Once`` を使用したプレイバックのアニメーションの最終フレームもピッタリのタイミングでサンプリングされないかもしれません。ゲームのあるフレームで、アニメーションはアニメーションの終わりの直前でサンプリングするかもしれず次のフレームでアニメーションの長さを超えるために、無効化されてその後サンプリングされません。アニメーションのピッタリとした最終フレームが絶対に必要である場合、 ``WrapMode.ClampForever`` を使用すべきであり、これによりアニメーションを自ら停止するまで、最終フレームを必ずサンプリングを続けます。
