!プロファイリング / Profiling

Unityプロファイラが使用するポートは:
	マルチキャストポート : 54998
	リスナーポート : 55000 - 55511
	マルチキャスト(ユニットテスト) : 55512 - 56023
ネットワーク ノードの中からアクセス出来る必要があります。つまりプロファイリングを行うデバイスはプロファイラを有効にしてUnityエディタ上でマシンのポートをみることが出来る必要があります。

!!最初のステップ

Unityはスキニング、バッチング、物理計算、ユーザスクリプト、パーティクルについてCPUに依存します（部分的にはSIMD、例えばx86ならSSE、ARMならNEON）。

GPUはシェーダ、ドローコール、イメージ エフェクトで使用されます。

!!!CPU の制約か GPU の制約か

*CPUおよびGPUの処理時間（ms）を検知するのに内部プロファイラを使用して下さい。

!!!パレート分析
大部分の問題 (80%) は少数の問題(20%)により引き起こされます。エディタ プロファイラを使用することで、関数呼び出しのうち最もプロセッサ負荷の高いものから順に発見して最適化できるようになります。通常はいくつかの影響の大きい関数を最適化することで全体的な速度を大きく改善させることが出来ます。

本当に必要なときだけに関数が実行されていることも確認が必要です。例えば、 ''OnBecameVisible'' と ''OnBecameInvisible'' のようなイベントを使用して表示されていないオブジェクトだけ検知して、更新対象としないことが出来ます。コルーチンにより毎フレーム実行しないけども定期的に実行が必要な更新に活用できます:-

[@
// 毎フレーム毎に何か処理
void Update () {
}

//0.2秒毎に何か処理
IEnumerator Start ()_ {
   while (true) {
      yield return new WaitForSeconds (0.2f);
   }
}
@]

''.NET System.Threading.Thread'' クラスを使用して重い処理は別スレッドで実行できます。これによりマルチコア実行出来ますが Unity API はスレッドに完全には対応していないことに留意して下さい。入力内容や結果はバッファしておき、読み込んだうえでメインスレッドに割り当てをしないと Unity APIでは活用できません。

!!CPU プロファイリング

!!!ユーザ コードのプロファイリング

全てのユーザコードがプロファイラに表示されるわけではありません。しかし ''Profiler.BeginSample'' および ''Profiler.EndSample'' を使用さて必要なユーザ コードをプロファイラに表示させることが出来ます。

!!GPU プロファイリング

Unityエディタ プロファイラは現時点でGPUデータは表示出来ません。われわれはハードウェア製造元と協力をしながらエディタプロファイラにTegraデバイスでは表示出来るように進めています。

!iOS!
>>ios<<
!!! iOS向けツール

*Unity 内部プロファイラ（エディタ プロファイラではなく）。これはシーン全体のGPU時間を表示します。
*PowerVR PVRUniSCo シェーダ アナライザ。以下を参照下さい。
*iOS: Xcode OpenGL ES ドライバ Instruments ではハイレベルな情報のみが表示されます:
**"Device Utilization %" - 全体の中でレンダリングに要したGPU 時間。95%以上の場合はGPU 制約を受けていることを示します。
**"Renderer Utilization %" - ピクセル描画に要したGPU 時間。
**"Tiler Utilization %" - 頂点処理に要したGPU 時間。
**"Split count" - フレーム スプリット数、すなわち割り当てられたバッファに当てはまらなかった頂点データ。

PowerVR はタイルベース ディファード レンダラ であり、ドローコール毎のGPUタイミングを取得することは不可能です。しかしシーン全体のGPU時間を取得するのにUnityのビルトイン プロファイラを使用出来ます（Xcodeに結果出力する分）。現在AppleツールはGPUおよびそのパーツがどれだけビジーかのみ伝達し、ミリ秒単位で知ることは出来ません。

PVRUniSCo によりシェーダ コードの中のシェーダ全体のサイクルをWindows および Macともに知ることが出来ます。しかしAppleドライバの状況を正確には反映出来ていません。それでもラフな指標としては十分です。
>><<

!Android!
>>android<<
!!!Androidツール

*Adreno (Qualcomm)
*NVPerfHUD (NVIDIA)
*PVRTune, PVRUniSCo (PowerVR)

Tegraでは、NVIDIAから最高級のパフォーマンス測定ツールが提供されていて実現したいことのすべてが出来ます - ドローコール毎のGPU時間、シェーダ毎のサイクル、強制 2x2 テクスチャ、Nullビュー四角形、でWindows, OSX, Linuxにて動作します。PerfHUD ESはコンシューマ デバイスで上手く動作しないためNVIDIAのdevelopment board が必要です。

Qualcomm により優秀なAdreno Profiler (Windows のみ) が提供されていてWindowsのみですが、タイムライン グラフ

フレーム キャプチャ、APIコール、シェーダ アナライザ、ライブ編集の機能があります。
>><<

!!!グラフィックス関連 CPU プロファイリング
内部プロファイラによりモジュール毎の良い概要が得られます:
*OpenGL ES APIに要した時間
*バッチング効率
*スキニング、アニメーション、パーティクル

!!メモリ

Unityメモリおよび Mono メモリ

!!!Mono メモリ

Mono メモリはスクリプトオブジェクト、Unityオブジェクトのラッパー（ゲームオブジェクト、アセット、コンポーネント、その他）をハンドリングします。ガーベージ コレクションにより、利用可能なメモリへの割り当てが出来なかった場合、または ''System.GC.Collect()'' コールの場合、クリーンアップを行います。

メモリはヒープブロックに割り当てされます。ヒープブロックはアプリが閉じられるまでMonoに保持されます。すなわち Mono は使用メモリをOS に対して開放しません (Unity 3.x)。特定の量のメモリを割り当てるとMonoのために予約されてOSでは利用可能ではありません。リリースしたときも Mono で内部的に利用可能となるのみでOSにとつては利用可能ではありません。プロファイラのヒープメモリは増加するのみで、減ることがありません。

もしシステムが割り当てたヒープブロックに新しいデータを当てはめる領域が十分にない場合、Mono により "GC" がコールされ、新しいヒープブロックを割り当て出来るようになります（例えばフラグメンテーションにより）。

ヒープのセクションがありすぎるということは Mono メモリを使い切ったことを意味します（フラグメンテーションまたは重い処理により）。

''System.GC.GetTotalMemory'' をしようして Mono でメモリ使用量の合計を取得します。

一般的なアドバイスとしては、出来るかぎり割り当ては小さくします。

!!!Unity メモリ

Unity メモリはアセット データ（テクスチャ、メッシュ、音声、アニメーション、等）、ゲームオブジェクト、エンジン内部処理（レンダリング、パーティクル、物理計算、その他）をハンドリングします。
''Profiler.usedHeapSize'' を使用してUnity メモリ使用量の合計を取得します。

!!!メモリマップ
ツールはまだ存在しませんが次のものが使用出来ます。

*Unity プロファイラ - 完璧ではなく、スキップするものもあるが、概要情報を得ることが出来ます。デバイス上でも動作します。
*内部プロファイラ
**使用済みヒープおよび割り当て済みヒープが表示されます。monoメモリを参照して下さい。
**フレーム毎の mono メモリ割り当てを表示します。
*Xcode ツール - iOS
**Xcode Instruments Activity Monitor - Real Memory列をみて下さい
**Xcode Instruments Allocations - 作成済みおよび有効なオブジェクトの割り当て
**VM Tracker
***テクスチャはIOKitラベルにより割り当てされます。
***メッシュはVM Allocateに入ります
*自身でツールを作成
**''FindObjectsOfTypeAll (type : Type) : Object[]''
**''FindObjectsOfType (type : Type): Object[]''
**''GetRuntimeMemorySize (o : Object) : int	''
**''GetMonoHeapSize''
**''GetMonoUsedSize''
**''Profiler.BeginSample/EndSample'' - 自身のコードをプロファイリング
**''UnloadUnusedAssets () : AsyncOperation''
**''System.GC.GetTotalMemory/Profiler.usedHeapSize''
*ロードされたオブジェクトへの参照 - これを知る方法はありません。回避方法としてパブリック変数の参照をFindすることです。

!!!メモリ による処理低下

*ガーベージ コレクター
**システムが割り当て済みヒープブロックに新しいデータ領域を確保出来ない場合に実行
** モバイルで ''OnGUI'' は使用しないこと
*** 毎フレーム数回実行
***ビューを完全に書き換え
***ガーベージ コレクション実行を必要とする大量のメモリ割り当てをコール
**多くのオブジェクトの作成／破棄が頻繁に行い過ぎていないか？
***フラグメンテーションにつながるThis may lead to fragmentation.
***Editor プロファイラを使用してメモリ活動をトラッキング
***内部プロファイラを使用してmono メモリ活動のトラッキングを実施可能
**処理低下があっても問題ないときに ''System.GC.Collect()'' という ''.Net'' 関数を使用可能
*新しいメモリの割り当て
**処理低下タイミングの割り当て
***割り当て済み、再利用可能なクラス インスタンスを使用して自身のメモリ管理スキームを実装
***フレーム毎に膨大なメモリ割り当てをせず、代わりにキャッシュして事前割り当てすべき
**フラグメンテーションでの問題がある場合はどうするか
***メモリプールを事前割り当て
***非アクティブなゲームオブジェクトの一覧を保持してインスタンス化、破棄の代わりに再利用
**mono メモリが不足
***メモリ活動のプロファイリング - 最初のメモリはいつ一杯になっているか？
***ひとつのメモリページでは足りないほどゲームオブジェクトは本当に必要ですか?
**ローカルデータではクラスの代わりに構造体を使用して下さい。ヒープ上にクラスは格納され、構造体はスタックに格納されます。
*関連するセクションをマニュアルを次のリンク先で確認  http://docs.unity3d.com/Documentation/Manual/UnderstandingAutomaticMemoryManagement.html

!!!メモリ不足によるクラッシュ

どこかの時点でゲームはメモリ不足 "out of memory" でクラッシュするかもしれませんが、理論的には十分なはずです。これが発生した場合、通常のゲームメモリ使用量と今回割り当てされたメモリの大きさを比較します。もし数字にかなり差がある場合、メモリの急増が発生しています。これの要因としては:
*同時に二つの大きなシーンがロードされる - 二つの大きなシーンの間に空のシーンを挟んでこれを解消
*追加シーン ローディング - 未使用のパーツを取り除いてメモリサイズを維持
*メモリにロードされた巨大なアセットバンドル
*次のようなWWW経由のロードまたは（大量の）大きなオブジェクトのインスタンス化:
**適切な圧縮のないテクスチャ（モバイルでは絶対にしない）
**Get/Set ピクセルを有効化したテクスチャ。非圧縮のテクスチャがメモリに必要となります
**実行時にJPEG/PNGからロードされたテクスチャは本質的に非圧縮
**大きなmp3ファイルで、decompress on loadin（ロード時に解凍）とマーキングされたもの
*未使用アセットを、シーンが変わってもクリアされないstatic な monobehavior フィールドのような、異様なキャッシュに入れてないか

